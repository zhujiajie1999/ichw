# ichw
1.图灵证明停机问题是因为他希望证明不存在一个算法，能够计算任何算法在给定输入下是否会终止
证明方法如下：
假设存在算法G（P，I）可以判断程序P在输入I时是否会停机
现定义算法H（P），实施时调用G（P，P）
如果G（P，P）停机，H（P）无限循环
如果G（P，P）无限循环，H（P）停机
int G(P,I);
int H(P)
{
if (G(P,P) == 1)
{ 
return 0;
}
else对应的
{ 
while(1){}
}
假设G(H，H)输出停机，那么H(H)进入死循环，由定义知二者矛盾，故不存在一个算法，能够计算任何算法在给定输入下是否会终止
该问题的本质是逻辑体系的不自恰性


2.为了表示正负数，计算机内一般将二进制数的首位作为符号位，用0表示正，用1表示负，右边各位表示数值。
以16位定点二进制整数为例，当x=+110011011111001时，对应的补码为0110011011111001，即正数的补码和原码一样。
当x=-110011011111001时，对应的补码为1001100100000111，即对于负数，原码和补码的后15位相加等于2^16。
补码表示法的优点是适合CPU做机器算术运算，加减法中两个补码二进制数可以像无符号数一样直接加减，无需做试探算法


3.±0     *     0000 0000       000 0000 0000 0000 0000 0000
±1.0     *     0111 1111       000 0000 0000 0000 0000 0000
最大非规范化数   *  0000 0000     111 1111 1111 1111 1111 1111
最小非规范化数   *  0000 0000     000 0000 0000 0000 0000 0001
最小规范化浮点数 *  0000 0001     000 0000 0000 0000 0000 0000
最大规范化浮点数 *  1111 1110     111 1111 1111 1111 1111 1111
±∞             *   1111 1111     000 0000 0000 0000 0000 0000 
NaN            *   1111 1111     non zero
